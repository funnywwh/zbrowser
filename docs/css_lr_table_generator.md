# CSS LR 解析表生成器设计

## 概述

使用 Zig 的 `comptime` 特性在编译时生成 LR 解析表，提升运行时性能。

## LR(1) 自动机构建算法

### 1. LR 项目（Item）

LR 项目表示语法规则的一个位置，例如：
- `A -> α·β` 表示已识别 α，期望 β
- `A -> ·αβ` 表示点在开头
- `A -> αβ·` 表示点在末尾（可归约）

### 2. 项目集（Item Set）

项目集是一组 LR 项目的集合，表示解析器的一个状态。

### 3. 闭包计算（Closure）

对于项目集 I，闭包 CLOSURE(I) 包含：
- I 中的所有项目
- 对于每个项目 `A -> α·Bβ`，如果 B 是非终结符，添加所有 `B -> ·γ` 形式的项目

### 4. GOTO 函数

GOTO(I, X) 表示从状态 I 在符号 X 上的转换：
- 对于 I 中的每个项目 `A -> α·Xβ`，添加 `A -> αX·β` 到新状态
- 计算新状态的闭包

### 5. 状态构建

1. 构建初始状态 I₀ = CLOSURE({S' -> ·S})
2. 对于每个状态 I 和每个符号 X，计算 GOTO(I, X)
3. 如果 GOTO(I, X) 不在状态集合中，添加为新状态
4. 重复直到没有新状态

### 6. ACTION 和 GOTO 表填充

- ACTION[I, a] = shift J，如果 GOTO(I, a) = J 且 a 是终结符
- ACTION[I, a] = reduce r，如果 `A -> α·` 在 I 中且 a 在 FOLLOW(A) 中
- ACTION[I, $] = accept，如果 `S' -> S·` 在 I 中
- GOTO[I, A] = J，如果 GOTO(I, A) = J 且 A 是非终结符

## 实现计划

### 阶段 1：基础数据结构 ✅
- [x] Item 结构
- [x] ItemSet 结构
- [x] 解析表结构

### 阶段 2：闭包计算 ⏳
- [ ] 实现 CLOSURE 函数
- [ ] 处理非终结符的展开

### 阶段 3：GOTO 计算 ⏳
- [ ] 实现 GOTO 函数
- [ ] 处理状态转换

### 阶段 4：状态构建 ⏳
- [ ] 构建初始状态
- [ ] 状态集合管理
- [ ] 状态编号分配

### 阶段 5：表填充 ⏳
- [ ] ACTION 表填充
- [ ] GOTO 表填充
- [ ] 冲突检测和处理

### 阶段 6：优化 ⏳
- [ ] 表压缩
- [ ] 性能优化

## 技术细节

### Comptime 限制

Zig 的 `comptime` 有一些限制：
- 不能使用动态分配（需要使用固定大小数组）
- 需要所有值在编译时已知
- 可以使用递归，但需要小心栈溢出

### 数据结构选择

- 使用固定大小数组存储状态
- 使用位图或集合表示项目集
- 使用哈希表或数组查找状态

### 冲突处理

LR(1) 可能遇到：
- Shift-Reduce 冲突
- Reduce-Reduce 冲突

需要：
- 检测冲突
- 报告错误或使用优先级解决

## 当前状态

- ✅ 基础数据结构已定义
- ✅ Comptime 函数框架已实现
- ✅ LR(0) 自动机构建算法已实现
- ✅ ACTION 和 GOTO 表生成已实现
- ✅ 测试通过（11/11）

## 实现完成的功能

### 1. LR 项目（Item）✅
- 项目结构定义
- 项目相等性检查
- 获取下一个符号
- 检查可归约性

### 2. LR 项目集（ItemSet）✅
- 项目集结构（使用固定大小数组）
- 添加项目（去重）
- 闭包计算（CLOSURE）
- GOTO 计算
- 项目集相等性检查

### 3. LR(0) 自动机构建 ✅
- 初始项目集构建
- 状态集合管理
- 状态转换计算
- ACTION 表填充（shift 和 reduce）
- GOTO 表填充

## 技术说明

### LR(0) vs LR(1)

当前实现使用 LR(0) 算法，这是 LR(1) 的简化版本：
- **LR(0)**：只使用项目集，不考虑前瞻符号
- **LR(1)**：使用项目集和前瞻符号，更精确但更复杂

对于大多数 CSS 语法，LR(0) 已经足够。如果遇到冲突，可以：
1. 使用优先级解决
2. 升级到 LR(1)
3. 使用 LALR(1)（LR(1) 的优化版本）

### 当前限制

1. **状态数量限制**：最多 30 个状态（MAX_STATES）
2. **项目数量限制**：每个状态最多 100 个项目
3. **简化归约**：LR(0) 对所有终结符都添加归约动作（可能产生冲突）
4. **Delimiter 处理**：T_DELIM 需要特殊处理（根据字符决定动作）

## 下一步优化

1. **冲突检测和处理**
   - 检测 shift-reduce 冲突
   - 检测 reduce-reduce 冲突
   - 使用优先级解决冲突

2. **LR(1) 升级**
   - 实现 FOLLOW 集计算
   - 实现前瞻符号处理
   - 升级到完整的 LR(1) 算法

3. **性能优化**
   - 解析表压缩
   - 状态合并（LALR）
   - 查找优化

4. **Delimiter 处理**
   - 为不同的 delimiter 字符创建不同的终结符
   - 或者在运行时根据字符选择动作

