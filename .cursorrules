# Cursor AI开发规则 - Headless浏览器渲染引擎

## 项目概述
这是一个使用Zig 0.15.2从零开始实现的headless浏览器渲染引擎，支持HTML5、CSS3和现代JavaScript，输出PNG图片，0外部依赖。

## 环境初始化
- **必须使用 `env.sh` 初始化开发环境**
- **必须在项目根目录执行 `env.sh`**：在项目根目录（包含 `env.sh` 的目录）运行 `source env.sh` 或 `. env.sh` 来设置环境变量
- `env.sh` 会将项目本地的 Zig 0.15.2 编译器路径添加到 PATH 环境变量
- **版本验证**：`env.sh` 会自动验证 Zig 版本是否为 0.15.2，如果版本不匹配会报错并退出
- 确保使用项目指定的 Zig 版本（0.15.2），避免版本不兼容问题
- 在运行任何 Zig 命令（如 `zig build`、`zig test`、`zig fmt`）之前，必须先初始化环境
- **执行方式**：
  ```bash
  cd /path/to/zbrowser  # 切换到项目根目录
  source env.sh          # 或使用 . env.sh
  # 如果版本正确，会显示: ✓ Zig版本验证通过: 0.15.2
  # 如果版本错误，会显示错误信息并退出
  ```
- **版本验证失败处理**：如果 `env.sh` 报错说版本不匹配，需要：
  1. 检查 `zig-x86_64-linux-0.15.2/zig` 文件是否存在
  2. 确认该文件是可执行的 Zig 0.15.2 编译器
  3. 如果不存在，需要下载 Zig 0.15.2 并解压到 `zig-x86_64-linux-0.15.2` 目录

## 开发规范

### 代码风格
- 使用`zig fmt`格式化所有代码
- 函数命名：camelCase
- 类型命名：PascalCase
- 常量命名：UPPER_SNAKE_CASE
- 所有公共API必须有文档注释（///）
- **简化实现必须添加TODO注释**：如果某个功能是简化实现（由于时间限制、复杂度考虑或分阶段开发），必须在代码中添加TODO注释，说明这是简化实现，并描述完整实现的计划

### 内存管理
- **绝对不能有内存泄漏**：所有分配的内存必须被正确释放
- 使用Zig的内存安全特性
- 明确所有权，避免内存泄漏
- 使用Arena分配器管理DOM节点生命周期
- 大对象使用GeneralPurposeAllocator
- 每个 `init` 函数必须有对应的 `deinit` 函数
- 使用 `defer` 确保资源在函数返回前释放
- 使用 `errdefer` 确保错误路径也释放资源
- 测试代码必须使用 `GeneralPurposeAllocator` 并检查内存泄漏
- 所有通过 `allocator.alloc`、`allocator.dupe` 等分配的内存必须通过 `allocator.free` 释放
- 所有通过 `ArrayList`、`HashMap` 等数据结构分配的内存必须调用对应的 `deinit` 方法

### 错误处理
- 使用Zig的错误处理机制（Error Union Types）
- 所有可能失败的操作必须返回错误
- 提供清晰的错误信息
- HTML/CSS解析要有容错机制

### 测试要求（TDD - 测试驱动开发）
- **强制要求：必须先写测试，再写实现代码**
- 开发新功能时必须遵循TDD流程：
  1. 先编写测试用例（包括正常情况、边界条件、错误情况）
  2. 运行测试确认失败（Red）
  3. 编写最小实现使测试通过（Green）
  4. 重构代码优化实现（Refactor）
  5. 重复上述流程直到功能完成
- 每个公开函数必须有测试
- **边界条件必须有测试**（详见下方边界测试规则）
- 错误情况必须有测试
- 目标：100%代码覆盖率
- 测试文件放在tests/目录，与src结构对应
- **内存泄漏检测**：所有测试必须使用 `GeneralPurposeAllocator` 并在测试结束时检查内存泄漏
- 测试中必须确保所有分配的资源都被正确释放，不能有任何内存泄漏
- **禁止先写实现代码再补测试**：必须先有测试用例

### 边界测试规则（必须遵循）
**边界测试是测试要求的核心组成部分，每个函数都必须包含边界测试用例。**

#### 边界测试类型（必须覆盖）
1. **空值/空集合测试**
   - 空字符串、空数组、空列表、空映射
   - null/undefined值处理
   - 空节点、空文档、空容器
   - 示例：`test "function with empty input"`、`test "function with null parameter"`

2. **零值/最小值测试**
   - 数值为0的情况
   - 最小长度、最小尺寸
   - 单元素集合
   - 示例：`test "function with zero value"`、`test "function with single element"`

3. **最大值/极限值测试**
   - 最大长度、最大尺寸、最大数量
   - 数值边界（如f32的最大值、最小值）
   - 示例：`test "function with maximum length"`、`test "function with max value"`

4. **特殊字符/Unicode测试**
   - 特殊字符：`<`, `>`, `&`, `"`, `'`, 空格、换行符
   - Unicode字符：中文、日文、韩文等多字节字符
   - Emoji字符：各种emoji表情符号
   - HTML实体编码：`&lt;`, `&gt;`, `&amp;`, `&quot;`, `&#39;` 等
   - 示例：`test "function with special characters"`、`test "function with unicode"`、`test "function with emoji"`

5. **不完整/错误格式测试**
   - 不完整的标签、属性、注释
   - 格式错误的输入（如未闭合的引号、标签）
   - 嵌套错误（如未闭合的标签）
   - 示例：`test "function with incomplete input"`、`test "function with malformed data"`

6. **边界组合测试**
   - 多个边界条件同时出现
   - 边界值之间的交互
   - 示例：`test "function with multiple edge cases"`

#### 边界测试编写要求
- **每个函数必须至少包含2-3个边界测试用例**
- 边界测试用例数量应该与正常测试用例数量相当或更多
- 边界测试必须独立于正常测试，单独编写
- 边界测试命名格式：`test "function_name boundary_case - description"`
- 边界测试必须使用 `GeneralPurposeAllocator` 进行内存泄漏检测
- 边界测试必须验证函数在边界条件下的正确行为（包括错误处理）

#### 边界测试示例场景
- **字符串处理函数**：空字符串、单字符、最大长度字符串、特殊字符、Unicode、emoji
- **数组/列表处理函数**：空数组、单元素、最大长度、null元素
- **数值计算函数**：0、负数、最大值、最小值、NaN、Infinity
- **HTML解析函数**：空HTML、不完整标签、嵌套错误、特殊字符、实体编码、Unicode
- **CSS解析函数**：空CSS、不完整规则、特殊字符、Unicode
- **布局函数**：空容器、零尺寸、最大尺寸、负值、边界换行
- **DOM操作函数**：空节点、null节点、不存在的元素、边界索引

#### 边界测试检查清单
在编写测试时，必须检查以下项目：
- [ ] 是否测试了空值/空集合情况？
- [ ] 是否测试了零值/最小值情况？
- [ ] 是否测试了最大值/极限值情况？
- [ ] 是否测试了特殊字符/Unicode/emoji情况？
- [ ] 是否测试了不完整/错误格式情况？
- [ ] 是否测试了边界组合情况？
- [ ] 边界测试是否使用了内存泄漏检测？
- [ ] 边界测试是否验证了错误处理？

### 模块组织
- 每个模块独立，接口清晰
- 避免循环依赖
- 使用Zig的模块系统（@import）

### Chrome兼容性
- 严格遵循Chrome最新版本规范
- 参考HTML5、CSS3、ECMAScript规范
- 渲染结果要与Chrome视觉一致
- 通过Chrome对比测试验证

### 性能要求
- 关键路径要优化
- 使用缓存减少重复计算
- 考虑使用SIMD优化图像处理

### 文档要求
- 复杂算法必须有注释
- 公共API必须有文档注释
- 使用Zig文档注释格式（///）
- 所有文档文件保存在docs/目录
- API文档必须包含参数说明、返回值说明和使用示例
- 文档更新后必须同步更新docs/目录中的相应文件

### TODO注释规范（简化实现标记）
**所有简化实现必须添加TODO注释，以便后续完善。**

#### TODO注释使用场景
- 功能简化实现（由于时间限制或复杂度考虑）
- 分阶段开发中的临时实现
- 已知的性能优化点（当前实现可工作但需要优化）
- 已知的边界情况处理不完整（当前实现覆盖主要场景）
- 已知的规范兼容性问题（当前实现不完全符合规范）

#### TODO注释格式要求
- 使用Zig标准注释格式：`// TODO: 描述内容`
- 必须说明这是简化实现
- 必须描述完整实现的计划或需要完成的工作
- 可以包含参考规范、实现思路或技术要点

#### TODO注释示例
```zig
// TODO: 简化实现 - 当前只支持基本的行内布局，需要实现完整的IFC（Inline Formatting Context）规范
// 完整实现需要支持：
// 1. 行内框的对齐（vertical-align）
// 2. 行内框的基线计算
// 3. 行内替换元素的处理
// 参考：CSS 2.1规范 9.4.2节

// TODO: 简化实现 - 当前只处理ASCII字符，需要支持完整的Unicode字符宽度计算
// 完整实现需要：
// 1. 使用Unicode字符宽度数据库（如East Asian Width属性）
// 2. 处理组合字符和变音符号
// 3. 处理emoji字符的宽度计算
```

#### TODO注释检查清单
在提交代码前，必须检查：
- [ ] 所有简化实现是否都添加了TODO注释？
- [ ] TODO注释是否说明了这是简化实现？
- [ ] TODO注释是否描述了完整实现的计划？
- [ ] TODO注释是否包含了必要的技术细节或参考？

## 开发流程（严格遵循TDD）
**必须严格按照以下顺序进行开发，不得跳过任何步骤：**

1. **编写测试用例（Red阶段）**
   - 先编写测试文件（tests/目录）
   - 包含正常情况、边界条件、错误情况的测试
   - **边界测试要求**：每个函数必须至少包含2-3个边界测试用例（空值、零值、最大值、特殊字符、不完整输入等）
   - 运行测试确认失败（因为实现还不存在）
   
2. **编写最小实现（Green阶段）**
   - 编写最小代码使测试通过
   - 不要过度设计，只实现测试要求的功能
   - **如果使用简化实现**：必须在代码中添加TODO注释，说明这是简化实现，并描述完整实现的计划
   - 运行测试确认通过
   
3. **重构优化（Refactor阶段）**
   - 在测试通过的基础上优化代码
   - 提高代码质量、可读性、性能
   - 每次重构后运行测试确保仍然通过
   
4. **代码质量检查**
   - 运行 `zig fmt` 格式化代码
   - 检查linter错误并修复
   - 检查代码覆盖率（目标100%）
   - 检查内存泄漏（所有测试必须通过内存泄漏检测）
   - **检查TODO注释**：确保所有简化实现都添加了TODO注释，并符合TODO注释规范

**重要原则：**
- 任何时候都不允许先写实现代码再补测试
- 如果发现缺少测试，必须先补测试，再修改实现
- 修改现有代码时，如果涉及新功能，必须先添加测试

## 禁止事项
- **绝对禁止先写实现再写测试**：必须遵循TDD，先写测试
- **绝对禁止修改不相关的代码**：只修改与当前任务直接相关的代码，不要修改其他无关的代码、函数或文件
- **绝对禁止跳过边界测试**：每个函数必须包含边界测试用例，不能只写正常情况的测试
- **绝对禁止简化实现不添加TODO注释**：所有简化实现必须添加TODO注释，说明这是简化实现并描述完整实现计划
- **绝对禁止在非项目根目录执行 `env.sh`**：必须在项目根目录（包含 `env.sh` 的目录）执行环境初始化，否则Zig编译器路径无法正确设置
- **绝对禁止忽略版本验证错误**：如果 `env.sh` 报错说Zig版本不匹配，必须修复版本问题后才能继续开发，不能使用错误版本的Zig编译器
- 不要使用外部依赖（除Zig标准库）
- 不要硬编码魔法数字
- 不要忽略错误
- 不要跳过测试
- **绝对禁止内存泄漏**：任何分配的内存必须被释放
- 不要忘记调用 `deinit` 方法
- 不要在错误路径中忘记释放资源（必须使用 `errdefer`）
- 不要在测试中忽略内存泄漏警告
- 不要在没有测试的情况下编写新功能
- 不要在边界测试中忽略内存泄漏检测

