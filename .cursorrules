# Cursor AI开发规则 - Headless浏览器渲染引擎

## 项目概述
这是一个使用Zig 0.15.2从零开始实现的headless浏览器渲染引擎，支持HTML5、CSS3和现代JavaScript，输出PNG图片，0外部依赖。

## 环境初始化
- **必须使用环境初始化脚本初始化开发环境**
- **必须在项目根目录执行环境初始化脚本**：在项目根目录（包含环境初始化脚本的目录）运行相应的脚本来设置环境变量
- 环境初始化脚本会将项目本地的 Zig 0.15.2 编译器路径添加到 PATH 环境变量
- **版本验证**：环境初始化脚本会自动验证 Zig 版本是否为 0.15.2，如果版本不匹配会报错并退出
- 确保使用项目指定的 Zig 版本（0.15.2），避免版本不兼容问题
- 在运行任何 Zig 命令（如 `zig build`、`zig test`、`zig fmt`）之前，必须先初始化环境

### Linux/WSL 环境初始化
- **使用 `env.sh` 初始化开发环境**
- **执行方式**：
  ```bash
  cd /path/to/zbrowser  # 切换到项目根目录
  source env.sh          # 或使用 . env.sh
  # 如果版本正确，会显示: ✓ Zig版本验证通过: 0.15.2
  # 如果版本错误，会显示错误信息并退出
  ```
- **版本验证失败处理**：如果 `env.sh` 报错说版本不匹配，需要：
  1. 检查 `zig-x86_64-linux-0.15.2/zig` 文件是否存在
  2. 确认该文件是可执行的 Zig 0.15.2 编译器
  3. 如果不存在，需要下载 Zig 0.15.2 并解压到 `zig-x86_64-linux-0.15.2` 目录

### Windows 环境初始化
- **使用 `env.ps1` 初始化开发环境（PowerShell）**
- **必须在项目根目录执行 `env.ps1`**：在项目根目录（包含 `env.ps1` 的目录）运行 `. .\env.ps1` 或 `.\env.ps1` 来设置环境变量
- `env.ps1` 会将项目本地的 Zig 0.15.2 编译器路径添加到 PATH 环境变量
- **版本验证**：`env.ps1` 会自动验证 Zig 版本是否为 0.15.2，如果版本不匹配会报错并退出
- **执行方式（PowerShell）**：
  ```powershell
  cd D:\wingo\zw\zbrowser  # 切换到项目根目录
  . .\env.ps1              # 或使用 .\env.ps1
  # 如果版本正确，会显示: [OK] Zig version verified: 0.15.2
  # 如果版本错误，会显示错误信息并退出
  ```
- **执行方式（CMD）**：
  ```cmd
  cd D:\wingo\zw\zbrowser  # 切换到项目根目录
  env.bat                   # 运行批处理脚本
  ```
- **版本验证失败处理**：如果 `env.ps1` 报错说版本不匹配，需要：
  1. 检查 `zig-x86_64-windows-0.15.2\zig.exe` 文件是否存在
  2. 确认该文件是可执行的 Zig 0.15.2 编译器
  3. 如果不存在，需要下载 Zig 0.15.2 Windows版本并解压到 `zig-x86_64-windows-0.15.2` 目录
- **绝对禁止在非项目根目录执行 `env.ps1`**：必须在项目根目录（包含 `env.ps1` 的目录）执行环境初始化，否则Zig编译器路径无法正确设置
- **绝对禁止忽略版本验证错误**：如果 `env.ps1` 报错说Zig版本不匹配，必须修复版本问题后才能继续开发，不能使用错误版本的Zig编译器

## 开发规范

### 代码风格
- 使用`zig fmt`格式化所有代码
- 函数命名：camelCase
- 类型命名：PascalCase
- 常量命名：UPPER_SNAKE_CASE
- 所有公共API必须有文档注释（///）
- **简化实现必须添加TODO注释**：如果某个功能是简化实现（由于时间限制、复杂度考虑或分阶段开发），必须在代码中添加TODO注释，说明这是简化实现，并描述完整实现的计划

### 代码复用规则
- **禁止重复代码**：如果发现相同或相似的代码逻辑在多个地方出现，必须提取为可复用的函数
- **提取重复逻辑**：当遇到以下情况时，必须提取为函数：
  - 相同的代码块在2个或更多地方出现
  - 相似的代码逻辑只有参数或操作对象不同
  - 重复的解析、转换、验证逻辑
- **函数设计原则**：
  - 提取的函数应该有清晰的职责和单一目的
  - 函数命名应该描述其功能，而不是实现细节
  - 使用参数化处理差异，而不是复制代码
  - 私有辅助函数使用小写开头的camelCase命名（如 `parsePxValue`）
  - 如果提取的函数只在一个模块内使用，应该声明为 `fn`（私有函数）
- **重构步骤**：
  1. 识别重复代码模式
  2. 提取通用逻辑为函数
  3. 用函数调用替换重复代码
  4. 确保所有测试仍然通过
  5. 运行 `zig fmt` 格式化代码
- **常见重复模式示例**：
  - 解析相同格式的字符串（如px单位、颜色值等）
  - 处理相同的数据结构（如四边值、简写属性等）
  - 相同的错误处理逻辑
  - 相同的验证或转换逻辑

### 内存管理
- **绝对不能有内存泄漏**：所有分配的内存必须被正确释放
- 使用Zig的内存安全特性
- 明确所有权，避免内存泄漏
- 使用Arena分配器管理DOM节点生命周期
- 大对象使用GeneralPurposeAllocator
- 每个 `init` 函数必须有对应的 `deinit` 函数
- 使用 `defer` 确保资源在函数返回前释放
- 使用 `errdefer` 确保错误路径也释放资源
- 测试代码必须使用 `GeneralPurposeAllocator` 并检查内存泄漏
- 所有通过 `allocator.alloc`、`allocator.dupe` 等分配的内存必须通过 `allocator.free` 释放
- 所有通过 `ArrayList`、`HashMap` 等数据结构分配的内存必须调用对应的 `deinit` 方法

### 错误处理
- 使用Zig的错误处理机制（Error Union Types）
- 所有可能失败的操作必须返回错误
- 提供清晰的错误信息
- HTML/CSS解析要有容错机制

### 编译错误避免规则
**在编写代码时，必须遵循以下规则以避免常见的Zig编译错误。遇到编译错误时，先参考 `docs/COMPILE_ERRORS.md` 查找解决方案。**

#### 类型安全规则
- ✅ **明确区分 `const` 和 `var`**：函数参数尽量使用 `const` 类型（如果不需要修改）
- ✅ **明确区分 `[]const T` 和 `[]T`**：需要修改的切片使用 `[]T`，不需要修改的使用 `[]const T`
- ✅ **明确区分 `?T`（可选）和 `!T`（错误联合）**：可选类型表示可能为null，错误联合类型表示可能失败
- ✅ **可选类型必须显式处理**：使用 `.?` 解包（确定非null）或 `if (value) |v| { ... }` 检查
- ✅ **错误联合类型必须使用 `try` 或 `catch`**：所有返回 `!T` 的函数调用必须使用 `try` 或 `catch` 处理
- ✅ **数组字面量必须使用 `&` 取地址**：`&[_]T{...}` 而不是 `[_]T{...}`
- ✅ **明确区分数组 `[N]T`、数组指针 `*[N]T`、切片 `[]T`**

#### 内存管理规则（已在内存管理章节，此处强调避免编译错误）
- ✅ **所有 `allocator.alloc/dupe` 必须配对 `allocator.free`**
- ✅ **使用 `defer` 立即释放资源**：`defer allocator.free(ptr);`
- ✅ **使用 `errdefer` 处理错误路径**：`errdefer list.deinit();`
- ✅ **每个 `init` 函数必须有对应的 `deinit` 函数**
- ✅ **所有 `ArrayList`、`HashMap` 等必须调用 `deinit`**
- ✅ **Arena分配的内存必须在Arena生命周期内使用**：Arena销毁后不能使用Arena分配的内存

#### 字符串和切片规则
- ✅ **字符串字面量通常可以隐式转换为 `[]const u8`**：如果不行，使用切片语法 `str[0..]`
- ✅ **访问字符串前检查索引范围**：使用 `if (index < str.len) { str[index] }` 或切片 `str[i..i+1]`

#### 结构体和函数规则
- ✅ **函数签名必须完全匹配**：包括错误联合类型、参数类型、返回类型
- ✅ **结构体初始化时包含所有必需字段**：使用IDE自动补全避免字段名错误
- ✅ **需要修改的结构体使用 `var` 声明**：不能修改 `const` 结构体的字段

#### 导入和模块规则
- ✅ **使用相对路径导入**：`@import("path/to/module")`
- ✅ **删除未使用的导入**：避免 `import of 'module_name' is unused` 错误
- ✅ **避免循环依赖**：模块A导入模块B，模块B不能导入模块A

#### 测试规则（已在测试章节，此处强调避免编译错误）
- ✅ **测试函数签名**：`test "name" { ... }`，可以返回 `!void` 处理错误
- ✅ **测试必须使用 `GeneralPurposeAllocator` 检测内存泄漏**

#### 构建系统规则
- ✅ **`build.zig` 中的路径必须与实际文件路径匹配**：使用相对路径引用源文件

#### 编译错误处理流程（自动记录规则）
**重要：AI在遇到编译错误时，必须自动执行以下流程：**

1. **遇到编译错误时（自动执行）**：
   - **第一步**：先查看 `docs/COMPILE_ERRORS.md` 查找相同或类似的错误
   - **第二步**：如果文档中已有相同错误，直接使用文档中的解决方案修复
   - **第三步**：如果文档中没有相同错误，执行以下自动记录流程：
     a. **分析错误**：提取错误类型、错误信息、错误位置
     b. **分析原因**：分析导致错误的常见原因
     c. **提供解决方案**：提供修复方案
     d. **提取避免规则**：总结避免此类错误的规则
     e. **自动记录**：使用模板自动添加到 `docs/COMPILE_ERRORS.md` 相应分类中
     f. **更新规则**：如果错误类型是新的，自动更新 `.cursorrules` 中的避免规则
     g. **修复代码**：按照解决方案修复代码

2. **编写代码时**：
   - 主动遵循上述避免规则
   - 使用IDE自动补全避免拼写错误
   - 在提交代码前运行 `zig build` 确保编译通过

3. **自动记录错误的标准格式**：
   - 错误必须按照 `docs/COMPILE_ERRORS.md` 中的模板格式记录
   - 错误必须添加到正确的分类中（类型不匹配、内存管理、错误处理等）
   - 如果错误属于新分类，创建新的分类章节
   - 记录后更新文档的"更新日志"部分

4. **自动更新规则的标准**：
   - 如果错误对应的避免规则在 `.cursorrules` 中不存在，必须添加
   - 规则添加到相应的子章节（类型安全规则、内存管理规则等）
   - 规则格式：`- ✅ **规则描述**：具体说明`

### 测试要求（TDD - 测试驱动开发）
- **强制要求：必须先写测试，再写实现代码**
- 开发新功能时必须遵循TDD流程：
  1. 先编写测试用例（包括正常情况、边界条件、错误情况）
  2. 运行测试确认失败（Red）
  3. 编写最小实现使测试通过（Green）
  4. 重构代码优化实现（Refactor）
  5. 重复上述流程直到功能完成
- 每个公开函数必须有测试
- **边界条件必须有测试**（详见下方边界测试规则）
- 错误情况必须有测试
- 目标：100%代码覆盖率
- 测试文件放在tests/目录，与src结构对应
- **内存泄漏检测**：所有测试必须使用 `GeneralPurposeAllocator` 并在测试结束时检查内存泄漏
- 测试中必须确保所有分配的资源都被正确释放，不能有任何内存泄漏
- **禁止先写实现代码再补测试**：必须先有测试用例

### 单元测试代码规范（详细要求）
**所有测试代码必须遵循以下规范，确保测试质量、可维护性和完整性。**

#### 测试代码结构模板
每个测试函数必须遵循以下标准结构：

```zig
test "测试名称 - 描述性说明" {
    // 1. 初始化内存分配器（必须使用GeneralPurposeAllocator）
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();  // 检查内存泄漏
    const allocator = gpa.allocator();
    
    // 2. 准备测试数据
    const test_data = "test input";
    
    // 3. 创建测试对象（如果需要）
    var test_object = try TestObject.init(allocator);
    defer test_object.deinit();  // 确保资源释放
    
    // 4. 执行测试操作
    const result = try test_object.doSomething(test_data);
    
    // 5. 验证结果
    try std.testing.expect(result != null);
    try std.testing.expectEqual(expected_value, result.?);
    
    // 6. 清理资源（defer会自动执行）
}
```

#### 测试命名规范
- **格式**：`test "功能名称 - 测试场景"`
- **正常情况**：`test "function_name - normal case"`
- **边界情况**：`test "function_name boundary_case - description"`
- **错误情况**：`test "function_name - error case"`
- **示例**：
  - `test "parseHTML - simple structure"`
  - `test "FontManager boundary - empty cache"`
  - `test "loadFont - file not found error"`

#### 测试覆盖要求
每个函数必须包含以下类型的测试：

1. **正常情况测试**（至少1个）
   - 测试函数在正常输入下的行为
   - 验证返回值和副作用
   - 示例：`test "parseHTML - simple structure"`

2. **边界情况测试**（至少2-3个，详见边界测试规则）
   - 空值/空集合
   - 零值/最小值
   - 最大值/极限值
   - 特殊字符/Unicode
   - 不完整/错误格式
   - 示例：`test "parseHTML boundary_case - empty input"`

3. **错误情况测试**（所有可能的错误路径）
   - 无效输入
   - 资源不足
   - 文件不存在
   - 格式错误
   - 示例：`test "loadFont - file not found error"`

4. **内存管理测试**（每个使用内存的函数）
   - 验证无内存泄漏
   - 验证资源正确释放
   - 验证错误路径也释放资源

#### 内存泄漏检测规范
**所有测试必须使用GeneralPurposeAllocator并检查内存泄漏：**

```zig
test "example test" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();  // 必须检查返回值，确保无泄漏
    const allocator = gpa.allocator();
    
    // 测试代码...
    
    // 测试结束时，gpa.deinit()会自动检查内存泄漏
    // 如果有泄漏，测试会失败
}
```

**重要规则**：
- ✅ **必须使用 `GeneralPurposeAllocator`**：不能使用 `page_allocator` 或其他分配器
- ✅ **必须检查 `deinit()` 返回值**：`defer _ = gpa.deinit();` 会检查是否有泄漏
- ✅ **所有分配的资源必须释放**：使用 `defer` 确保释放
- ✅ **错误路径也必须释放资源**：使用 `errdefer` 处理错误情况

#### 测试断言规范
使用Zig标准库的测试断言：

```zig
// 相等性断言
try std.testing.expectEqual(expected, actual);
try std.testing.expectEqualStrings(expected, actual);

// 布尔断言
try std.testing.expect(condition);
try std.testing.expectError(expected_error, function());

// 可选类型断言
try std.testing.expect(result != null);
try std.testing.expect(result == null);

// 错误断言
try std.testing.expectError(error.ExpectedError, function());
```

#### 测试数据准备规范
1. **使用有意义的测试数据**：
   ```zig
   const html_content = "<html><body><p>Hello</p></body></html>";
   const css_content = "body { color: red; }";
   ```

2. **创建测试辅助函数**（如果数据复杂）：
   ```zig
   fn createMinimalTTF(allocator: std.mem.Allocator) ![]u8 {
       // 创建最小有效TTF数据
   }
   ```

3. **使用测试辅助模块**（`tests/test_helpers.zig`）：
   ```zig
   const test_helpers = @import("test_helpers");
   const doc = try test_helpers.createTestDocument(allocator);
   defer test_helpers.cleanupTestDocument(allocator, doc);
   ```

#### 测试组织规范
1. **测试文件结构**：
   - 测试文件放在 `tests/` 目录
   - 与 `src/` 目录结构对应
   - 测试文件命名：`模块名_test.zig`

2. **测试分组**：
   ```zig
   // 正常情况测试
   test "function_name - normal case 1" { ... }
   test "function_name - normal case 2" { ... }
   
   // 边界情况测试
   test "function_name boundary_case - empty input" { ... }
   test "function_name boundary_case - max value" { ... }
   
   // 错误情况测试
   test "function_name - error case 1" { ... }
   test "function_name - error case 2" { ... }
   ```

3. **测试辅助函数**：
   - 复杂的测试数据创建函数放在测试文件顶部
   - 可复用的辅助函数放在 `tests/test_helpers.zig`

#### 测试代码质量要求
1. **可读性**：
   - 测试名称清晰描述测试内容
   - 测试代码简洁明了
   - 使用有意义的变量名

2. **独立性**：
   - 每个测试应该独立运行
   - 不依赖其他测试的执行顺序
   - 不共享状态

3. **完整性**：
   - 测试应该验证所有重要的行为
   - 包括正常路径、边界路径、错误路径
   - 验证返回值和副作用

4. **性能**：
   - 测试应该快速执行
   - 避免不必要的资源分配
   - 使用合适的测试数据大小

#### 测试代码示例模板

**示例1：简单函数测试**
```zig
test "calculateSum - normal case" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();
    
    const result = calculateSum(10, 20);
    try std.testing.expectEqual(@as(i32, 30), result);
}

test "calculateSum boundary_case - zero values" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();
    
    const result = calculateSum(0, 0);
    try std.testing.expectEqual(@as(i32, 0), result);
}
```

**示例2：需要内存管理的测试**
```zig
test "parseHTML - simple structure" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();
    
    const html_content = "<html><body><p>Hello</p></body></html>";
    const doc = try dom.Document.init(allocator);
    defer doc.deinit();
    
    var parser = html.Parser.init(html_content, doc, allocator);
    defer parser.deinit();
    try parser.parse();
    
    const body = doc.getBody();
    try std.testing.expect(body != null);
}

test "parseHTML boundary_case - empty input" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();
    
    const html_content = "";
    const doc = try dom.Document.init(allocator);
    defer doc.deinit();
    
    var parser = html.Parser.init(html_content, doc, allocator);
    defer parser.deinit();
    try parser.parse();
    
    // 空输入应该不会崩溃
    try std.testing.expect(true);
}
```

**示例3：错误情况测试**
```zig
test "loadFont - file not found error" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();
    
    var font_manager = font.FontManager.init(allocator);
    defer font_manager.deinit();
    
    const result = font_manager.loadFont("nonexistent.ttf", "TestFont");
    try std.testing.expectError(error.FileNotFound, result);
}
```

#### 测试检查清单
编写测试时，必须检查以下项目：
- [ ] 是否使用了 `GeneralPurposeAllocator`？
- [ ] 是否检查了 `gpa.deinit()` 的返回值？
- [ ] 是否所有分配的资源都使用 `defer` 释放？
- [ ] 是否测试了正常情况？
- [ ] 是否测试了至少2-3个边界情况？
- [ ] 是否测试了所有错误情况？
- [ ] 测试名称是否清晰描述测试内容？
- [ ] 测试是否独立运行（不依赖其他测试）？
- [ ] 是否验证了返回值和副作用？

### 边界测试规则（必须遵循）
**边界测试是测试要求的核心组成部分，每个函数都必须包含边界测试用例。**

#### 边界测试类型（必须覆盖）
1. **空值/空集合测试**
   - 空字符串、空数组、空列表、空映射
   - null/undefined值处理
   - 空节点、空文档、空容器
   - 示例：`test "function with empty input"`、`test "function with null parameter"`

2. **零值/最小值测试**
   - 数值为0的情况
   - 最小长度、最小尺寸
   - 单元素集合
   - 示例：`test "function with zero value"`、`test "function with single element"`

3. **最大值/极限值测试**
   - 最大长度、最大尺寸、最大数量
   - 数值边界（如f32的最大值、最小值）
   - 示例：`test "function with maximum length"`、`test "function with max value"`

4. **特殊字符/Unicode测试**
   - 特殊字符：`<`, `>`, `&`, `"`, `'`, 空格、换行符
   - Unicode字符：中文、日文、韩文等多字节字符
   - Emoji字符：各种emoji表情符号
   - HTML实体编码：`&lt;`, `&gt;`, `&amp;`, `&quot;`, `&#39;` 等
   - 示例：`test "function with special characters"`、`test "function with unicode"`、`test "function with emoji"`

5. **不完整/错误格式测试**
   - 不完整的标签、属性、注释
   - 格式错误的输入（如未闭合的引号、标签）
   - 嵌套错误（如未闭合的标签）
   - 示例：`test "function with incomplete input"`、`test "function with malformed data"`

6. **边界组合测试**
   - 多个边界条件同时出现
   - 边界值之间的交互
   - 示例：`test "function with multiple edge cases"`

#### 边界测试编写要求
- **每个函数必须至少包含2-3个边界测试用例**
- 边界测试用例数量应该与正常测试用例数量相当或更多
- 边界测试必须独立于正常测试，单独编写
- 边界测试命名格式：`test "function_name boundary_case - description"`
- 边界测试必须使用 `GeneralPurposeAllocator` 进行内存泄漏检测
- 边界测试必须验证函数在边界条件下的正确行为（包括错误处理）

#### 边界测试示例场景
- **字符串处理函数**：空字符串、单字符、最大长度字符串、特殊字符、Unicode、emoji
- **数组/列表处理函数**：空数组、单元素、最大长度、null元素
- **数值计算函数**：0、负数、最大值、最小值、NaN、Infinity
- **HTML解析函数**：空HTML、不完整标签、嵌套错误、特殊字符、实体编码、Unicode
- **CSS解析函数**：空CSS、不完整规则、特殊字符、Unicode
- **布局函数**：空容器、零尺寸、最大尺寸、负值、边界换行
- **DOM操作函数**：空节点、null节点、不存在的元素、边界索引

#### 边界测试检查清单
在编写测试时，必须检查以下项目：
- [ ] 是否测试了空值/空集合情况？
- [ ] 是否测试了零值/最小值情况？
- [ ] 是否测试了最大值/极限值情况？
- [ ] 是否测试了特殊字符/Unicode/emoji情况？
- [ ] 是否测试了不完整/错误格式情况？
- [ ] 是否测试了边界组合情况？
- [ ] 边界测试是否使用了内存泄漏检测？
- [ ] 边界测试是否验证了错误处理？

### 模块组织
- 每个模块独立，接口清晰
- 避免循环依赖
- 使用Zig的模块系统（@import）

### Chrome兼容性
- 严格遵循Chrome最新版本规范
- 参考HTML5、CSS3、ECMAScript规范
- 渲染结果要与Chrome视觉一致
- 通过Chrome对比测试验证

### 性能要求
- 关键路径要优化
- 使用缓存减少重复计算
- 考虑使用SIMD优化图像处理

### 文档要求
- 复杂算法必须有注释
- 公共API必须有文档注释
- 使用Zig文档注释格式（///）
- 所有文档文件保存在docs/目录
- API文档必须包含参数说明、返回值说明和使用示例
- 文档更新后必须同步更新docs/目录中的相应文件

### TODO注释规范（简化实现标记）
**所有简化实现必须添加TODO注释，以便后续完善。**

#### TODO注释使用场景
- 功能简化实现（由于时间限制或复杂度考虑）
- 分阶段开发中的临时实现
- 已知的性能优化点（当前实现可工作但需要优化）
- 已知的边界情况处理不完整（当前实现覆盖主要场景）
- 已知的规范兼容性问题（当前实现不完全符合规范）

#### TODO注释格式要求
- 使用Zig标准注释格式：`// TODO: 描述内容`
- 必须说明这是简化实现
- 必须描述完整实现的计划或需要完成的工作
- 可以包含参考规范、实现思路或技术要点

#### TODO注释示例
```zig
// TODO: 简化实现 - 当前只支持基本的行内布局，需要实现完整的IFC（Inline Formatting Context）规范
// 完整实现需要支持：
// 1. 行内框的对齐（vertical-align）
// 2. 行内框的基线计算
// 3. 行内替换元素的处理
// 参考：CSS 2.1规范 9.4.2节

// TODO: 简化实现 - 当前只处理ASCII字符，需要支持完整的Unicode字符宽度计算
// 完整实现需要：
// 1. 使用Unicode字符宽度数据库（如East Asian Width属性）
// 2. 处理组合字符和变音符号
// 3. 处理emoji字符的宽度计算
```

#### TODO注释检查清单
在提交代码前，必须检查：
- [ ] 所有简化实现是否都添加了TODO注释？
- [ ] TODO注释是否说明了这是简化实现？
- [ ] TODO注释是否描述了完整实现的计划？
- [ ] TODO注释是否包含了必要的技术细节或参考？

## 开发流程（严格遵循TDD）
**必须严格按照以下顺序进行开发，不得跳过任何步骤：**

1. **编写测试用例（Red阶段）**
   - 先编写测试文件（tests/目录）
   - 包含正常情况、边界条件、错误情况的测试
   - **边界测试要求**：每个函数必须至少包含2-3个边界测试用例（空值、零值、最大值、特殊字符、不完整输入等）
   - 运行测试确认失败（因为实现还不存在）
   
2. **编写最小实现（Green阶段）**
   - 编写最小代码使测试通过
   - 不要过度设计，只实现测试要求的功能
   - **如果使用简化实现**：必须在代码中添加TODO注释，说明这是简化实现，并描述完整实现的计划
   - 运行测试确认通过
   
3. **重构优化（Refactor阶段）**
   - 在测试通过的基础上优化代码
   - 提高代码质量、可读性、性能
   - 每次重构后运行测试确保仍然通过
   
4. **代码质量检查**
   - **必须运行所有测试并确保全部通过**：任何代码修改后，必须运行 `zig test` 确保所有测试用例通过，不允许有任何测试失败
   - 运行 `zig fmt` 格式化代码
   - 检查linter错误并修复
   - 检查代码覆盖率（目标100%）
   - 检查内存泄漏（所有测试必须通过内存泄漏检测）
   - **检查TODO注释**：确保所有简化实现都添加了TODO注释，并符合TODO注释规范

**重要原则：**
- **任何修改都必须保证所有测试通过**：修改代码后必须运行 `zig test` 验证所有测试用例通过，如果测试失败必须修复代码直到所有测试通过
- 任何时候都不允许先写实现代码再补测试
- 如果发现缺少测试，必须先补测试，再修改实现
- 修改现有代码时，如果涉及新功能，必须先添加测试

## 禁止事项
- **绝对禁止提交失败的测试**：任何代码修改后，如果测试失败，必须修复代码直到所有测试通过，不允许提交或继续开发直到测试全部通过
- **绝对禁止先写实现再写测试**：必须遵循TDD，先写测试
- **绝对禁止修改不相关的代码**：只修改与当前任务直接相关的代码，不要修改其他无关的代码、函数或文件
- **绝对禁止跳过边界测试**：每个函数必须包含边界测试用例，不能只写正常情况的测试
- **绝对禁止简化实现不添加TODO注释**：所有简化实现必须添加TODO注释，说明这是简化实现并描述完整实现计划
- **绝对禁止遇到编译错误不记录**：遇到新的编译错误时，必须自动记录到 `docs/COMPILE_ERRORS.md` 并更新 `.cursorrules` 中的规则，不能只修复代码而不记录
- **绝对禁止在非项目根目录执行环境初始化脚本**：必须在项目根目录（包含环境初始化脚本的目录）执行环境初始化，否则Zig编译器路径无法正确设置
  - Linux/WSL：必须在项目根目录执行 `env.sh`
  - Windows PowerShell：必须在项目根目录执行 `env.ps1`
  - Windows CMD：必须在项目根目录执行 `env.bat`
- **绝对禁止忽略版本验证错误**：如果环境初始化脚本报错说Zig版本不匹配，必须修复版本问题后才能继续开发，不能使用错误版本的Zig编译器
  - Linux/WSL：如果 `env.sh` 报错，必须修复版本问题
  - Windows：如果 `env.ps1` 或 `env.bat` 报错，必须修复版本问题
- 不要使用外部依赖（除Zig标准库）
- 不要硬编码魔法数字
- 不要忽略错误
- 不要跳过测试
- **绝对禁止内存泄漏**：任何分配的内存必须被释放
- 不要忘记调用 `deinit` 方法
- 不要在错误路径中忘记释放资源（必须使用 `errdefer`）
- 不要在测试中忽略内存泄漏警告
- 不要在没有测试的情况下编写新功能
- 不要在边界测试中忽略内存泄漏检测

